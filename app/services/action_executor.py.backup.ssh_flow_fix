"""
Action Executor Engine
Orchestrates execution of template actions with dependency resolution
"""
import time
import traceback
from typing import Dict, Any, List, Optional
from datetime import datetime
from collections import defaultdict, deque

from app import db
from flask import current_app
from app.models import (
    Workspace, WorkspaceTemplate, TemplateActionSequence,
    WorkspaceActionExecution
)
from app.services.action_handlers import (
    SSHKeyActionHandler,
    VerifySSHKeyHandler,
    GitCloneActionHandler,
    SystemPackagesActionHandler,
    PythonVenvActionHandler,
    PipRequirementsActionHandler,
    DirectoryActionHandler,
    ConfigFileActionHandler,
    PostgreSQLDatabaseActionHandler,
    VSCodeExtensionsActionHandler,
    EnvironmentVariablesActionHandler,
    ShellScriptActionHandler,
    SystemdServiceActionHandler,
    CompletionMessageActionHandler,
)


class ActionExecutor:
    """
    Orchestrates action-based workspace provisioning.

    Features:
    - DAG-based dependency resolution
    - Parallel execution where possible (future enhancement)
    - Automatic rollback on fatal errors
    - Fine-grained progress tracking
    - Conditional action execution
    """

    # Handler registry - maps action_type to handler class
    HANDLER_REGISTRY = {
        'generate_ssh_key': SSHKeyActionHandler,
        'verify_ssh_key': VerifySSHKeyHandler,
        'clone_git_repository': GitCloneActionHandler,
        'clone_git_repo': GitCloneActionHandler,  # Alias for backward compatibility
        'install_system_packages': SystemPackagesActionHandler,
        'create_python_venv': PythonVenvActionHandler,
        'install_pip_requirements': PipRequirementsActionHandler,
        'create_directory': DirectoryActionHandler,
        'create_file': ConfigFileActionHandler,  # Alias for create_file action
        'write_configuration_file': ConfigFileActionHandler,
        'create_postgresql_database': PostgreSQLDatabaseActionHandler,
        'install_vscode_extensions': VSCodeExtensionsActionHandler,
        'set_environment_variables': EnvironmentVariablesActionHandler,
        'execute_shell_script': ShellScriptActionHandler,
        'shell_script': ShellScriptActionHandler,  # Alias for shell_script action
        'run_script': ShellScriptActionHandler,  # Alias for run_script action
        'systemd_service': SystemdServiceActionHandler,
        'create_systemd_service': SystemdServiceActionHandler,  # Alias
        'display_completion_message': CompletionMessageActionHandler,
    }

    def __init__(self, workspace: Workspace, template: WorkspaceTemplate):
        """
        Initialize executor for a workspace and template.

        Args:
            workspace: Workspace instance
            template: WorkspaceTemplate instance with action sequences
        """
        self.workspace = workspace
        self.template = template
        self.completed_actions: List[WorkspaceActionExecution] = []
        self.failed_action: Optional[WorkspaceActionExecution] = None

    def execute_template_actions(self) -> Dict[str, Any]:
        """
        Execute all actions for the template.

        Returns:
            Dict with success status, completed actions, and error info
        """
        # Get all action sequences for this template, ordered by execution order
        action_sequences = TemplateActionSequence.query.filter_by(
            template_id=self.template.id,
            enabled=True
        ).order_by(TemplateActionSequence.order).all()

        if not action_sequences:
            return {
                'success': True,
                'message': 'No actions to execute',
                'completed_actions': []
            }

        # Resolve dependencies and create execution plan
        execution_plan = self._resolve_dependencies(action_sequences)

        # Set total steps for progress tracking
        total_steps = len(execution_plan)
        self.workspace.total_steps = total_steps
        self.workspace.provisioning_step = 0
        db.session.commit()

        # Execute actions in order
        for idx, action_seq in enumerate(execution_plan, 1):
            # Check if action should be executed based on condition
            if not self._should_execute_action(action_seq):
                self._skip_action(action_seq)
                continue

            # Create execution record
            execution = WorkspaceActionExecution(
                workspace_id=self.workspace.id,
                template_id=self.template.id,
                action_sequence_id=action_seq.id,
                action_id=action_seq.action_id,
                action_type=action_seq.action_type,
                max_attempts=action_seq.retry_config.get('max_attempts', 1)
            )
            db.session.add(execution)
            db.session.commit()

            # Execute action with retry logic
            success = self._execute_action_with_retry(action_seq, execution)

            if success:
                self.completed_actions.append(execution)

                # Update progress tracking
                self.workspace.provisioning_step = idx
                self.workspace.progress_percent = int((idx / total_steps) * 100)
                self.workspace.progress_message = f"Completed: {action_seq.action_id}"
                db.session.commit()

                # Check if should pause for SSH verification
                execution_result = execution.result or {}
                if self._should_pause_for_ssh_verification(action_seq, execution_result):
                    return self._pause_for_ssh_verification(execution_result)
            else:
                self.failed_action = execution

                # Check if this is a fatal error
                if action_seq.fatal_on_error:
                    # Rollback if configured
                    if self.template.rollback_on_fatal_error:
                        self._rollback_completed_actions()

                    return {
                        'success': False,
                        'error': f"Fatal error in action {action_seq.action_id}",
                        'failed_action': action_seq.action_id,
                        'completed_actions': [a.action_id for a in self.completed_actions],
                        'rolled_back': self.template.rollback_on_fatal_error
                    }
                else:
                    # Non-fatal error, continue execution
                    continue

        return {
            'success': True,
            'completed_actions': [a.action_id for a in self.completed_actions],
            'total_actions': len(execution_plan)
        }

    def _resolve_dependencies(self, action_sequences: List[TemplateActionSequence]) -> List[TemplateActionSequence]:
        """
        Resolve action dependencies and return execution order.

        Uses topological sort to handle dependencies while preserving
        explicit order values where possible.

        Args:
            action_sequences: List of action sequences to order

        Returns:
            Ordered list of action sequences
        """
        # Build dependency graph
        action_map = {seq.action_id: seq for seq in action_sequences}
        dependencies = defaultdict(list)
        in_degree = defaultdict(int)

        # Initialize all actions
        for seq in action_sequences:
            in_degree[seq.action_id] = 0

        # Build dependency edges
        for seq in action_sequences:
            deps = seq.dependencies or []
            for dep_id in deps:
                if dep_id in action_map:
                    dependencies[dep_id].append(seq.action_id)
                    in_degree[seq.action_id] += 1

        # Topological sort using Kahn's algorithm
        queue = deque([
            action_id for action_id in action_map.keys()
            if in_degree[action_id] == 0
        ])

        # Sort queue by action order for deterministic execution
        queue = deque(sorted(queue, key=lambda aid: action_map[aid].order))

        result = []

        while queue:
            # Get next action with no dependencies
            current_id = queue.popleft()
            result.append(action_map[current_id])

            # Process dependent actions
            for dependent_id in dependencies[current_id]:
                in_degree[dependent_id] -= 1
                if in_degree[dependent_id] == 0:
                    queue.append(dependent_id)

            # Keep queue sorted by order
            queue = deque(sorted(queue, key=lambda aid: action_map[aid].order))

        # Check for circular dependencies
        if len(result) != len(action_sequences):
            raise ValueError("Circular dependency detected in action sequences")

        return result

    def _should_execute_action(self, action_seq: TemplateActionSequence) -> bool:
        """
        Check if action should be executed based on runtime condition.

        Args:
            action_seq: Action sequence to check

        Returns:
            True if action should execute, False to skip
        """
        if not action_seq.condition:
            return True

        # Get handler class
        handler_class = self.HANDLER_REGISTRY.get(action_seq.action_type)
        if not handler_class:
            return True  # Execute if handler not found (will fail later)

        # Create handler instance
        handler = self._create_handler(handler_class)

        # Evaluate condition
        try:
            return handler.evaluate_condition(action_seq.condition)
        except Exception as e:
            # If condition evaluation fails, default to executing
            return True

    def _execute_action_with_retry(self,
                                   action_seq: TemplateActionSequence,
                                   execution: WorkspaceActionExecution) -> bool:
        """
        Execute action with retry logic.

        Args:
            action_seq: Action sequence to execute
            execution: Execution record to track

        Returns:
            True if successful, False if failed
        """
        # Get handler class
        handler_class = self.HANDLER_REGISTRY.get(action_seq.action_type)
        if not handler_class:
            error_msg = f"No handler registered for action type: {action_seq.action_type}"
            execution.mark_failed(error_msg)
            db.session.commit()
            return False

        # Create handler instance
        handler = self._create_handler(handler_class)

        # Get retry configuration
        retry_config = action_seq.retry_config or {}
        max_attempts = retry_config.get('max_attempts', 1)
        retry_delay = retry_config.get('retry_delay_seconds', 0)
        exponential_backoff = retry_config.get('exponential_backoff', False)

        # Execute with retries
        for attempt in range(1, max_attempts + 1):
            execution.attempt_number = attempt
            execution.mark_started()
            db.session.commit()

            start_time = time.time()

            try:
                # Substitute variables in parameters
                substituted_params = handler.substitute_variables(action_seq.parameters)
                
                # Validate parameters
                if not handler.validate(substituted_params):
                    raise ValueError("Parameter validation failed")

                # Execute action
                result = handler.execute(substituted_params)

                # Calculate duration
                duration = time.time() - start_time

                # Mark as completed
                execution.mark_completed(result=result, duration_seconds=duration)
                db.session.commit()

                return True

            except Exception as e:
                duration = time.time() - start_time
                error_msg = str(e)
                stack_trace = traceback.format_exc()

                if attempt < max_attempts:
                    # Calculate delay for retry
                    if exponential_backoff:
                        delay = retry_delay * (2 ** (attempt - 1))
                    else:
                        delay = retry_delay

                    # Wait before retry
                    if delay > 0:
                        time.sleep(delay)

                    # Continue to next attempt
                    continue
                else:
                    # Final attempt failed
                    execution.mark_failed(error_msg, stack_trace)
                    db.session.commit()
                    return False

        return False

    def _execute_single_action(self, action_seq: TemplateActionSequence) -> WorkspaceActionExecution:
        """
        Execute a single action and return the execution record.
        
        Helper method primarily for testing individual action execution.
        
        Args:
            action_seq: Action sequence to execute
            
        Returns:
            WorkspaceActionExecution record with results
        """
        # Create execution record
        execution = WorkspaceActionExecution(
            workspace_id=self.workspace.id,
            template_id=self.template.id,
            action_sequence_id=action_seq.id,
            action_id=action_seq.action_id,
            action_type=action_seq.action_type,
            max_attempts=action_seq.retry_config.get('max_attempts', 1)
        )
        db.session.add(execution)
        db.session.commit()
        
        # Execute action with retry logic
        self._execute_action_with_retry(action_seq, execution)
        
        # Return the execution record (refreshed from DB)
        db.session.refresh(execution)
        return execution

    def _skip_action(self, action_seq: TemplateActionSequence):
        """
        Skip action and record as skipped.

        Args:
            action_seq: Action sequence to skip
        """
        execution = WorkspaceActionExecution(
            workspace_id=self.workspace.id,
            template_id=self.template.id,
            action_sequence_id=action_seq.id,
            action_id=action_seq.action_id,
            action_type=action_seq.action_type,
            status=WorkspaceActionExecution.STATUS_SKIPPED
        )
        db.session.add(execution)
        db.session.commit()


    def _should_pause_for_ssh_verification(self, action_seq: TemplateActionSequence, result: Dict[str, Any]) -> bool:
        """
        Check if provisioning should pause for SSH key verification.

        Pauses after SSH key generation or verification if:
        - Action type is 'generate_ssh_key' or 'verify_ssh_key'
        - SSH key exists (generated or loaded)
        - Workspace doesn't have verified SSH already

        Args:
            action_seq: The action sequence that was just executed
            result: The result from the action handler

        Returns:
            True if should pause for SSH verification
        """
        # Only pause for SSH key actions (both generate and verify)
        if action_seq.action_type not in ['generate_ssh_key', 'verify_ssh_key']:
            return False

        # Check if action generated a public key
        if not result.get('public_key'):
            return False

        # Don't pause if SSH already verified (resuming from pause)
        if self.workspace.extra_data and self.workspace.extra_data.get('ssh_verified'):
            return False

        return True

    def _pause_for_ssh_verification(self, result: Dict[str, Any]) -> Dict[str, Any]:
        """
        Pause provisioning and set workspace state to await SSH verification.

        Args:
            result: Result from SSH key generation containing public_key

        Returns:
            Dict indicating provisioning paused for SSH verification
        """
        # Store SSH public key in workspace
        self.workspace.ssh_public_key = result.get('public_key')

        # Set provisioning state to awaiting SSH verification
        self.workspace.provisioning_state = 'awaiting_ssh_verification'
        self.workspace.progress_message = 'Awaiting SSH key verification'

        # Store metadata about pause
        extra_data = self.workspace.extra_data or {}
        extra_data['paused_at_action'] = result.get('action_id', 'ssh_key')
        extra_data['pause_timestamp'] = time.time()
        self.workspace.extra_data = extra_data

        db.session.commit()

        current_app.logger.info(
            f"Provisioning paused for workspace {self.workspace.id} - awaiting SSH verification"
        )

        return {
            'success': True,
            'paused_for_ssh': True,
            'completed_actions': [a.action_id for a in self.completed_actions],
            'message': 'Provisioning paused for SSH key verification',
            'ssh_public_key': result.get('public_key')
        }

    def resume_from_current_step(self) -> Dict[str, Any]:
        """
        Resume action execution from current provisioning step.

        This method continues executing remaining actions after a pause
        (e.g., after SSH key verification).

        Returns:
            Dict with success status and completed actions
        """
        # Get all action sequences for this template
        action_sequences = TemplateActionSequence.query.filter_by(
            template_id=self.template.id,
            enabled=True
        ).order_by(TemplateActionSequence.order).all()

        if not action_sequences:
            return {
                'success': True,
                'message': 'No actions to execute',
                'completed_actions': []
            }

        # Resolve dependencies
        execution_plan = self._resolve_dependencies(action_sequences)

        # Get current step (already completed)
        current_step = self.workspace.provisioning_step
        total_steps = len(execution_plan)

        current_app.logger.info(
            f"Resuming from step {current_step}/{total_steps} for workspace {self.workspace.id}"
        )

        # Execute remaining actions starting from next step
        for idx in range(current_step, total_steps):
            action_seq = execution_plan[idx]
            actual_idx = idx + 1  # 1-based index

            # Check if action should be executed
            if not self._should_execute_action(action_seq):
                self._skip_action(action_seq)
                continue

            # Create execution record
            execution = WorkspaceActionExecution(
                workspace_id=self.workspace.id,
                template_id=self.template.id,
                action_sequence_id=action_seq.id,
                action_id=action_seq.action_id,
                action_type=action_seq.action_type,
                max_attempts=action_seq.retry_config.get('max_attempts', 1)
            )
            db.session.add(execution)
            db.session.commit()

            # Execute action with retry
            success = self._execute_action_with_retry(action_seq, execution)

            if success:
                self.completed_actions.append(execution)

                # Update progress
                self.workspace.provisioning_step = actual_idx
                self.workspace.progress_percent = int((actual_idx / total_steps) * 100)
                self.workspace.progress_message = f"Completed: {action_seq.action_id}"
                db.session.commit()
            else:
                self.failed_action = execution

                # Check if fatal error
                if action_seq.fatal_on_error:
                    if self.template.rollback_on_fatal_error:
                        self._rollback_completed_actions()

                    return {
                        'success': False,
                        'error': f"Fatal error in action {action_seq.action_id}",
                        'failed_action': action_seq.action_id,
                        'completed_actions': [a.action_id for a in self.completed_actions],
                        'rolled_back': self.template.rollback_on_fatal_error
                    }
                else:
                    # Non-fatal, continue
                    continue

        return {
            'success': True,
            'completed_actions': [a.action_id for a in self.completed_actions],
            'total_actions': total_steps,
            'resumed_from_step': current_step
        }

    def _rollback_completed_actions(self):
        """
        Rollback completed actions in reverse order.
        """
        # Reverse order for rollback
        for execution in reversed(self.completed_actions):
            try:
                # Get action sequence
                action_seq = TemplateActionSequence.query.get(execution.action_sequence_id)
                if not action_seq:
                    continue

                # Get handler class
                handler_class = self.HANDLER_REGISTRY.get(action_seq.action_type)
                if not handler_class:
                    continue

                # Create handler instance
                handler = self._create_handler(handler_class)

                # Attempt rollback
                execution.rollback_attempted = True
                success = handler.rollback(action_seq.parameters, execution.result or {})

                if success:
                    execution.rollback_successful = True
                    execution.status = WorkspaceActionExecution.STATUS_ROLLED_BACK
                else:
                    execution.rollback_successful = False
                    execution.rollback_error = "Rollback returned False"

                db.session.commit()

            except Exception as e:
                execution.rollback_attempted = True
                execution.rollback_successful = False
                execution.rollback_error = str(e)
                db.session.commit()

    def _create_handler(self, handler_class):
        """
        Create handler instance with workspace context.

        Args:
            handler_class: Handler class to instantiate

        Returns:
            Handler instance
        """
        return handler_class(
            workspace_id=self.workspace.id,
            workspace_name=self.workspace.name,
            linux_username=self.workspace.linux_username,
            home_directory=f"/home/{self.workspace.linux_username}",
            user_email=self.workspace.owner.email if self.workspace.owner else None,
            user_id=self.workspace.owner_id,
            company_name=self.workspace.company.name if self.workspace.company else None,
            subdomain=self.workspace.subdomain,
            port=self.workspace.port
        )
